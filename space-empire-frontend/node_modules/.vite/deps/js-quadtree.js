import "./chunk-PLDDJCW6.js";

// ../space-empire-backend/node_modules/js-quadtree/dist/index.es.js
var i = class {
  constructor(i2, t2, s2, e2, n2) {
    this.x = i2, this.y = t2, this.w = s2, this.h = e2, this.data = n2;
  }
  contains(i2) {
    return i2.x >= this.x && i2.x <= this.x + this.w && i2.y >= this.y && i2.y <= this.y + this.h;
  }
  intersects(i2) {
    return !(i2.x > this.x + this.w || i2.x + i2.w < this.x || i2.y > this.y + this.h || i2.y + i2.h < this.y);
  }
};
var t = class {
  constructor(i2, t2, s2, e2) {
    this.x = i2, this.y = t2, this.r = s2, this.rPow2 = this.r * this.r, this.data = e2;
  }
  euclideanDistancePow2(i2, t2) {
    return Math.pow(i2.x - t2.x, 2) + Math.pow(i2.y - t2.y, 2);
  }
  contains(i2) {
    return this.euclideanDistancePow2(i2, this) <= this.rPow2;
  }
  intersects(i2) {
    const t2 = this.x - Math.max(i2.x, Math.min(this.x, i2.x + i2.w)), s2 = this.y - Math.max(i2.y, Math.min(this.y, i2.y + i2.h));
    return t2 * t2 + s2 * s2 <= this.rPow2;
  }
};
var s = class {
  constructor(i2, t2, s2) {
    this.x = i2, this.y = t2, this.data = s2;
  }
};
var e = { capacity: 4, removeEmptyNodes: false, maximumDepth: -1, arePointsEqual: (i2, t2) => i2.x === t2.x && i2.y === t2.y };
var n = class _n {
  constructor(i2, t2, s2 = []) {
    this.container = i2, this.config = Object.assign({}, e, t2), this.isDivided = false, this.points = [];
    for (const i3 of s2) this.insertRecursive(i3);
  }
  getTree() {
    let i2;
    return i2 = this.isDivided ? { ne: this.ne.getTree(), nw: this.nw.getTree(), se: this.se.getTree(), sw: this.sw.getTree() } : this.getNodePointAmount(), i2;
  }
  getAllPoints() {
    const i2 = [];
    return this.getAllPointsRecursive(i2), i2;
  }
  getAllPointsRecursive(i2) {
    this.isDivided ? (this.ne.getAllPointsRecursive(i2), this.nw.getAllPointsRecursive(i2), this.se.getAllPointsRecursive(i2), this.sw.getAllPointsRecursive(i2)) : Array.prototype.push.apply(i2, this.points.slice());
  }
  getNodePointAmount() {
    return this.points.length;
  }
  divide() {
    const t2 = -1 === this.config.maximumDepth ? -1 : this.config.maximumDepth - 1, s2 = Object.assign({}, this.config, { maximumDepth: t2 });
    this.isDivided = true;
    const e2 = this.container.x, h = this.container.y, r = this.container.w / 2, o = this.container.h / 2;
    this.ne = new _n(new i(e2 + r, h, r, o), s2), this.nw = new _n(new i(e2, h, r, o), s2), this.se = new _n(new i(e2 + r, h + o, r, o), s2), this.sw = new _n(new i(e2, h + o, r, o), s2), this.insert(this.points.slice()), this.points.length = 0, this.points = [];
  }
  remove(i2) {
    if (Array.isArray(i2)) for (const t2 of i2) this.removeRecursive(t2);
    else this.removeRecursive(i2);
  }
  removeRecursive(i2) {
    if (this.container.contains(i2)) if (this.isDivided) this.ne.removeRecursive(i2), this.nw.removeRecursive(i2), this.se.removeRecursive(i2), this.sw.removeRecursive(i2), this.config.removeEmptyNodes && (0 !== this.ne.getNodePointAmount() || this.ne.isDivided || 0 !== this.nw.getNodePointAmount() || this.nw.isDivided || 0 !== this.se.getNodePointAmount() || this.se.isDivided || 0 !== this.sw.getNodePointAmount() || this.sw.isDivided || (this.isDivided = false, delete this.ne, delete this.nw, delete this.se, delete this.sw));
    else {
      for (let t2 = this.points.length - 1; t2 >= 0; t2--) this.config.arePointsEqual(i2, this.points[t2]) && this.points.splice(t2, 1);
    }
  }
  insert(i2) {
    if (Array.isArray(i2)) {
      let t2 = true;
      for (const s2 of i2) t2 = t2 && this.insertRecursive(s2);
      return t2;
    }
    return this.insertRecursive(i2);
  }
  insertRecursive(i2) {
    if (!this.container.contains(i2)) return false;
    if (!this.isDivided) {
      if (this.getNodePointAmount() < this.config.capacity || 0 === this.config.maximumDepth) return this.points.push(i2), true;
      (-1 === this.config.maximumDepth || this.config.maximumDepth > 0) && this.divide();
    }
    return !!this.isDivided && (this.ne.insertRecursive(i2) || this.nw.insertRecursive(i2) || this.se.insertRecursive(i2) || this.sw.insertRecursive(i2));
  }
  query(i2) {
    const t2 = [];
    return this.queryRecursive(i2, t2), t2;
  }
  queryRecursive(i2, t2) {
    if (i2.intersects(this.container)) if (this.isDivided) this.ne.queryRecursive(i2, t2), this.nw.queryRecursive(i2, t2), this.se.queryRecursive(i2, t2), this.sw.queryRecursive(i2, t2);
    else {
      const s2 = this.points.filter((t3) => i2.contains(t3));
      Array.prototype.push.apply(t2, s2);
    }
  }
  clear() {
    this.points = [], this.isDivided = false, delete this.ne, delete this.nw, delete this.se, delete this.sw;
  }
};
export {
  i as Box,
  t as Circle,
  s as Point,
  n as QuadTree
};
//# sourceMappingURL=js-quadtree.js.map

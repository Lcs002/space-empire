{
  "version": 3,
  "sources": ["../../../../space-empire-backend/node_modules/js-quadtree/src/Box.ts", "../../../../space-empire-backend/node_modules/js-quadtree/src/Circle.ts", "../../../../space-empire-backend/node_modules/js-quadtree/src/Point.ts", "../../../../space-empire-backend/node_modules/js-quadtree/src/QuadTree.ts"],
  "sourcesContent": ["/**\n * Box class.\n * @class Box\n */\nimport {Point} from \"./Point\";\nimport {Shape, UserCustomData} from \"./types\";\n\nexport class Box implements Shape{\n    readonly x: number;\n    readonly y: number;\n    readonly w: number;\n    readonly h: number;\n    readonly data: UserCustomData;\n\n    /**\n     * Box constructor;\n     * @constructs Box\n     * @param {number} x - X coordinate of the box.\n     * @param {number} y - Y coordinate of the box.\n     * @param {number} w - Width of the box.\n     * @param {number} h - Height of the box.\n     * @param {*} [data] - Data to store along the box.\n     */\n    constructor(x: number, y: number, w: number, h: number, data?: UserCustomData) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n        this.data = data;\n    }\n\n    /**\n     * Check if a point is contained in the box.\n     * @param {Point|Object} point - The point to test if it is contained in the box.\n     * @returns {boolean} - True if the point is contained in the box, otherwise false.\n     */\n    contains(point: Point): boolean {\n        return point.x >= this.x &&\n            point.x <= this.x + this.w &&\n            point.y >= this.y &&\n            point.y <= this.y + this.h;\n    }\n\n    /**\n     * Check if a box intersects with this box.\n     * @param {Box|Object} range - The box to test the intersection with.\n     * @returns {boolean} - True if it intersects, otherwise false.\n     */\n    intersects(range: Box): boolean {\n        return !(range.x > this.x + this.w\n            || range.x + range.w < this.x\n            || range.y > this.y + this.h\n            || range.y + range.h < this.y);\n    }\n\n}\n", "/**\n * Box Circle.\n * @class Circle\n */\nimport {Point} from \"./Point\";\nimport {Box} from \"./Box\";\nimport {Shape, UserCustomData} from \"./types\";\n\nexport class Circle  implements Shape{\n    readonly x: number;\n    readonly y: number;\n    readonly r: number;\n    readonly rPow2: number;\n    readonly data: UserCustomData;\n\n    /**\n     * Circle constructor;\n     * @constructs Circle\n     * @param {number} x - X coordinate of the circle.\n     * @param {number} y - Y coordinate of the circle.\n     * @param {number} r - Radius of the circle.\n     * @param {*} [data] - Data to store along the circle.\n     */\n    constructor(x: number, y: number, r: number, data?: UserCustomData) {\n        this.x = x;\n        this.y = y;\n        this.r = r;\n        this.rPow2 = this.r * this.r; // To avoid square roots\n        this.data = data;\n    }\n\n    private euclideanDistancePow2(point1: Point, point2: Point): number {\n        return Math.pow((point1.x - point2.x), 2) + Math.pow((point1.y - point2.y), 2);\n    }\n\n    /**\n     * Check if a point is contained in the circle.\n     * @param {Point|Object} point - The point to test if it is contained in the circle.\n     * @returns {boolean} - True if the point is contained in the circle, otherwise false.\n     */\n    contains(point: Point): boolean {\n        return this.euclideanDistancePow2(point, this) <= this.rPow2;\n    }\n\n    /**\n     * Check if a box intersects with this circle.\n     * @param {Box|Object} range - The box to test the intersection with.\n     * @returns {boolean} - True if it intersects, otherwise false.\n     */\n    intersects(range: Box): boolean {\n        const dX = this.x - Math.max(range.x, Math.min(this.x, range.x + range.w));\n        const dY = this.y - Math.max(range.y, Math.min(this.y, range.y + range.h));\n        return (dX * dX + dY * dY) <= (this.rPow2);\n    }\n}\n", "/**\n * Point class.\n * @class Point\n */\nimport {UserCustomData} from \"./types\";\n\nexport class Point {\n    readonly x: number;\n    readonly y: number;\n    readonly data: UserCustomData;\n\n    /**\n     * Point constructor.\n     * @constructs Point\n     * @param {number} x - X coordinate of the point.\n     * @param {number} y - Y coordinate of the point.\n     * @param {*} [data] - Data to store along the point.\n     */\n    constructor(x: number, y: number, data?: UserCustomData) {\n        this.x = x;\n        this.y = y;\n        this.data = data;\n    }\n\n}", "import {Box} from './Box';\nimport {Point} from './Point';\nimport {QuadTreeConfig, QuadTreeConfigComplete, Tree, Shape} from \"./types\";\n\nconst defaultConfig: QuadTreeConfigComplete = {\n    capacity: 4,\n    removeEmptyNodes: false,\n    maximumDepth: -1,\n    arePointsEqual: (point1: Point, point2: Point) => point1.x === point2.x && point1.y === point2.y\n};\n\n/**\n * QuadTree class.\n * @class QuadTree\n */\nexport class QuadTree {\n    private readonly container: Box;\n    private isDivided: boolean;\n    private points: Point[];\n    private readonly config: QuadTreeConfigComplete;\n    private ne!: QuadTree;\n    private nw!: QuadTree;\n    private se!: QuadTree;\n    private sw!: QuadTree;\n\n    /**\n     * Create a new QuadTree\n     * @constructor\n     * @param {Box} container - The box on which the QuadTree will operate.\n     * @param {Object} [config] - The configuration of the quadtree.\n     * @param {number} [config.capacity] - The maximum amount of points per node.\n     * @param {boolean} [config.removeEmptyNodes] - Specify if the quadtree has to remove subnodes if they are empty.\n     * @param {number} [config.maximumDepth] - Specify the maximum depth of the tree.\n     * @param {function} [config.arePointsEqual] - Specify a custom method to compare point for removal.\n     * @param {(Object[]|Point[])} [points] - An array of initial points to insert in the QuadTree.\n     * @param {number} points[].x - X coordinate of the point.\n     * @param {number} points[].y - Y coordinate of the point.\n     */\n    constructor(container: Box, config?: QuadTreeConfig, points: Point[] = []) {\n        this.container = container;\n        this.config = Object.assign({}, defaultConfig, config);\n\n        this.isDivided = false;\n        this.points = [];\n\n        for (const point of points) {\n            this.insertRecursive(point);\n        }\n    }\n\n    /**\n     * Return a tree representation of the QuadTree\n     * @returns {{se: *, sw: *, ne: *, nw: *}|Number} - A tree representation of the QuadTree\n     */\n    getTree(): Tree {\n        let tree;\n\n        if (this.isDivided) {\n            tree = {\n                ne: this.ne.getTree(),\n                nw: this.nw.getTree(),\n                se: this.se.getTree(),\n                sw: this.sw.getTree()\n            };\n\n        } else {\n            tree = this.getNodePointAmount();\n        }\n\n        return tree;\n    }\n\n    /**\n     * Get all the points in the QuadTree\n     * @returns {(Object[]|Point[])} - An array containing all the points.\n     */\n    getAllPoints(): Point[] {\n        const pointsList: Point[] = [];\n        this.getAllPointsRecursive(pointsList);\n        return pointsList;\n    }\n\n    /**\n     * Get all the points in the QuadTree\n     * @param {(Object[]|Point[])} pointsList\n     * @private\n     */\n    private getAllPointsRecursive(pointsList: Point[]): void {\n        if (!this.isDivided) {\n            Array.prototype.push.apply(pointsList, this.points.slice());\n            return;\n        }\n\n        this.ne.getAllPointsRecursive(pointsList);\n        this.nw.getAllPointsRecursive(pointsList);\n        this.se.getAllPointsRecursive(pointsList);\n        this.sw.getAllPointsRecursive(pointsList);\n    }\n\n    /**\n     * Return the amount of points in this node.\n     * @returns {number} - The amount of points in this node.\n     * @private\n     */\n    private getNodePointAmount(): number {\n        return this.points.length;\n    }\n\n    /**\n     * Divide this node into 4 sub-nodes\n     * @private\n     */\n    private divide(): void {\n        const childMaximumDepth = this.config.maximumDepth === -1 ? -1 : this.config.maximumDepth - 1;\n        const childConfig: QuadTreeConfig = Object.assign({}, this.config, {maximumDepth: childMaximumDepth});\n\n        this.isDivided = true;\n\n        const x = this.container.x;\n        const y = this.container.y;\n        const w = this.container.w / 2;\n        const h = this.container.h / 2;\n\n        // Creation of the sub-nodes, and insertion of the current point\n        this.ne = new QuadTree(new Box(x + w, y, w, h), childConfig);\n        this.nw = new QuadTree(new Box(x, y, w, h), childConfig);\n        this.se = new QuadTree(new Box(x + w, y + h, w, h), childConfig);\n        this.sw = new QuadTree(new Box(x, y + h, w, h), childConfig);\n\n        this.insert(this.points.slice());\n\n        // We empty this node points\n        this.points.length = 0;\n        this.points = [];\n    }\n\n    /**\n     * Remove a point in the QuadTree\n     * @param {(Point|Object|Point[]|Object[])} pointOrArray - A point or an array of points to remove\n     * @param {number} pointOrArray.x - X coordinate of the point\n     * @param {number} pointOrArray.y - Y coordinate of the point\n     */\n    remove(pointOrArray: Point | Point[]): void {\n        if (Array.isArray(pointOrArray)) {\n            for (const point of pointOrArray) {\n                this.removeRecursive(point);\n            }\n        } else {\n            this.removeRecursive(pointOrArray);\n        }\n    }\n\n    /**\n     * Remove a point in the QuadTree\n     * @param {(Point|Object)} point - A point to remove\n     * @param {number} point.x - X coordinate of the point\n     * @param {number} point.y - Y coordinate of the point\n     * @private\n     */\n    private removeRecursive(point: Point): void {\n        if (!this.container.contains(point)) {\n            return;\n        }\n\n        if (!this.isDivided) {\n            const len = this.points.length;\n            for (let i = len - 1; i >= 0; i--) {\n                if (this.config.arePointsEqual(point, this.points[i])) {\n                    this.points.splice(i, 1);\n                }\n            }\n\n            return;\n        }\n\n        this.ne.removeRecursive(point);\n        this.nw.removeRecursive(point);\n        this.se.removeRecursive(point);\n        this.sw.removeRecursive(point);\n\n        if (this.config.removeEmptyNodes) {\n            if (this.ne.getNodePointAmount() === 0 && !this.ne.isDivided &&\n                this.nw.getNodePointAmount() === 0 && !this.nw.isDivided &&\n                this.se.getNodePointAmount() === 0 && !this.se.isDivided &&\n                this.sw.getNodePointAmount() === 0 && !this.sw.isDivided) {\n\n                this.isDivided = false;\n\n                delete this.ne;\n                delete this.nw;\n                delete this.se;\n                delete this.sw;\n            }\n        }\n    }\n\n    /**\n     * Insert a point in the QuadTree\n     * @param {(Point|Object|Point[]|Object[])} pointOrArray - A point or an array of points to insert\n     * @param {number} pointOrArray.x - X coordinate of the point\n     * @param {number} pointOrArray.y - Y coordinate of the point\n     * @returns {boolean} true if the point or all the point has been inserted, false otherwise\n     */\n    insert(pointOrArray: Point | Point[]): boolean {\n        if (Array.isArray(pointOrArray)) {\n            let returnValue = true;\n            for (const point of pointOrArray) {\n                returnValue = returnValue && this.insertRecursive(point);\n            }\n            return returnValue;\n        } else {\n            return this.insertRecursive(pointOrArray);\n        }\n    }\n\n    /**\n     * Insert a point in the QuadTree\n     * @param {(Point|Object)} point - A point to insert\n     * @param {number} point.x - X coordinate of the point\n     * @param {number} point.y - Y coordinate of the point\n     * @returns {boolean}\n     * @private\n     */\n    private insertRecursive(point: Point): boolean {\n        if (!this.container.contains(point)) {\n            return false;\n        }\n        if (!this.isDivided) {\n            if (this.getNodePointAmount() < this.config.capacity || this.config.maximumDepth === 0) {\n                this.points.push(point);\n                return true;\n            } else if (this.config.maximumDepth === -1 || this.config.maximumDepth > 0) {\n                this.divide();\n            }\n        }\n\n        if (this.isDivided) {\n            return this.ne.insertRecursive(point) \n                || this.nw.insertRecursive(point) \n                || this.se.insertRecursive(point) \n                || this.sw.insertRecursive(point);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Query all the point within a range\n     * @param {Shape} range - The range to test\n     * @returns {(Point[]|Object[])} - The points within the range\n     */\n    query(range: Shape): Point[] {\n        const pointsFound: Point[] = [];\n        this.queryRecursive(range, pointsFound);\n        return pointsFound;\n    }\n\n    /**\n     * @param {Shape} range\n     * @param {(Point[]|Object[])} pointsFound\n     * @returns {(Point[]|Object[])}\n     * @private\n     */\n    private queryRecursive(range: Shape, pointsFound: Point[]): void {\n        if (range.intersects(this.container)) {\n            if (this.isDivided) {\n                this.ne.queryRecursive(range, pointsFound);\n                this.nw.queryRecursive(range, pointsFound);\n                this.se.queryRecursive(range, pointsFound);\n                this.sw.queryRecursive(range, pointsFound);\n            } else {\n                const p = this.points.filter((point) => range.contains(point));\n\n                Array.prototype.push.apply(pointsFound, p);\n            }\n        }\n    }\n\n    /**\n     * Clear the QuadTree\n     */\n    clear(): void {\n        this.points = [];\n        this.isDivided = false;\n\n        delete this.ne;\n        delete this.nw;\n        delete this.se;\n        delete this.sw;\n    }\n}\n\n\n"],
  "mappings": ";;;IAOaA,UAAAA;EAgBTC,YAAYC,IAAWC,IAAWC,IAAWC,IAAWC,IAAAA;AACpDC,SAAKL,IAAIA,IACTK,KAAKJ,IAAIA,IACTI,KAAKH,IAAIA,IACTG,KAAKF,IAAIA,IACTE,KAAKD,OAAOA;EAAAA;EAQhBL,SAASO,IAAAA;AACL,WAAOA,GAAMN,KAAKK,KAAKL,KACnBM,GAAMN,KAAKK,KAAKL,IAAIK,KAAKH,KACzBI,GAAML,KAAKI,KAAKJ,KAChBK,GAAML,KAAKI,KAAKJ,IAAII,KAAKF;EAAAA;EAQjCJ,WAAWQ,IAAAA;AACP,WAAA,EAASA,GAAMP,IAAIK,KAAKL,IAAIK,KAAKH,KAC1BK,GAAMP,IAAIO,GAAML,IAAIG,KAAKL,KACzBO,GAAMN,IAAII,KAAKJ,IAAII,KAAKF,KACxBI,GAAMN,IAAIM,GAAMJ,IAAIE,KAAKJ;EAAAA;AAAAA;AAAAA,IC5C3BO,ID4C2BP,MC5C3BO;EAeTT,YAAYC,IAAWC,IAAWQ,IAAWL,IAAAA;AACzCC,SAAKL,IAAIA,IACTK,KAAKJ,IAAIA,IACTI,KAAKI,IAAIA,IACTJ,KAAKK,QAAQL,KAAKI,IAAIJ,KAAKI,GAC3BJ,KAAKD,OAAOA;EAAAA;EAGRL,sBAAsBY,IAAeC,IAAAA;AACzC,WAAOC,KAAKC,IAAKH,GAAOX,IAAIY,GAAOZ,GAAI,CAAA,IAAKa,KAAKC,IAAKH,GAAOV,IAAIW,GAAOX,GAAI,CAAA;EAAA;EAQhFF,SAASO,IAAAA;AACL,WAAOD,KAAKU,sBAAsBT,IAAOD,IAAAA,KAASA,KAAKK;EAAAA;EAQ3DX,WAAWQ,IAAAA;AACP,UAAMS,KAAKX,KAAKL,IAAIa,KAAKI,IAAIV,GAAMP,GAAGa,KAAKK,IAAIb,KAAKL,GAAGO,GAAMP,IAAIO,GAAML,CAAAA,CAAAA,GACjEiB,KAAKd,KAAKJ,IAAIY,KAAKI,IAAIV,GAAMN,GAAGY,KAAKK,IAAIb,KAAKJ,GAAGM,GAAMN,IAAIM,GAAMJ,CAAAA,CAAAA;AACvE,WAAQa,KAAKA,KAAKG,KAAKA,MAAQd,KAAU;EAAA;AAAA;AAAA,IC9CpCe,ID8CoC,MC9CpCA;EAYTrB,YAAYC,IAAWC,IAAWG,IAAAA;AAC9BC,SAAKL,IAAIA,IACTK,KAAKJ,IAAIA,IACTI,KAAKD,OAAOA;EAAAA;AAAAA;ACjBpB,IAAMiB,IAAwC,EAC1CC,UAAU,GACVC,kBAAAA,OACAC,cAAAA,IACAC,gBAAgB,CAACd,IAAeC,OAAkBD,GAAOX,MAAMY,GAAOZ,KAAKW,GAAOV,MAAMW,GAAOX,EAAAA;AAAAA,IAOtFyB,IAPsFzB,MAOtFyB,GAAAA;EAuBT3B,YAAY4B,IAAgBC,IAAyBC,KAAkB,CAAA,GAAA;AACnExB,SAAKsB,YAAYA,IACjBtB,KAAKuB,SAASE,OAAOC,OAAO,CAAA,GAAIV,GAAeO,EAAAA,GAE/CvB,KAAK2B,YAAAA,OACL3B,KAAKwB,SAAS,CAAA;AAEd,eAAWvB,MAASuB,GAChBxB,MAAK4B,gBAAgB3B,EAAAA;EAAAA;EAQ7BP,UAAAA;AACI,QAAImC;AAcJ,WAXIA,KADA7B,KAAK2B,YACE,EACHG,IAAI9B,KAAK8B,GAAGC,QAAAA,GACZC,IAAIhC,KAAKgC,GAAGD,QAAAA,GACZE,IAAIjC,KAAKiC,GAAGF,QAAAA,GACZG,IAAIlC,KAAKkC,GAAGH,QAAAA,EAAAA,IAIT/B,KAAKmC,mBAAAA,GAGTN;EAAAA;EAOXnC,eAAAA;AACI,UAAM0C,KAAsB,CAAA;AAE5B,WADApC,KAAKqC,sBAAsBD,EAAAA,GACpBA;EAAAA;EAQH1C,sBAAsB0C,IAAAA;AACrBpC,SAAK2B,aAKV3B,KAAK8B,GAAGO,sBAAsBD,EAAAA,GAC9BpC,KAAKgC,GAAGK,sBAAsBD,EAAAA,GAC9BpC,KAAKiC,GAAGI,sBAAsBD,EAAAA,GAC9BpC,KAAKkC,GAAGG,sBAAsBD,EAAAA,KAP1BE,MAAMC,UAAUC,KAAKC,MAAML,IAAYpC,KAAKwB,OAAOkB,MAAAA,CAAAA;EAAAA;EAenDhD,qBAAAA;AACJ,WAAOM,KAAKwB,OAAOmB;EAAAA;EAOfjD,SAAAA;AACJ,UAAMkD,KAAAA,OAAoB5C,KAAKuB,OAAOJ,eAAAA,KAA2BnB,KAAKuB,OAAOJ,eAAe,GACtF0B,KAA8BpB,OAAOC,OAAO,CAAA,GAAI1B,KAAKuB,QAAQ,EAACJ,cAAcyB,GAAAA,CAAAA;AAElF5C,SAAK2B,YAAAA;AAEL,UAAMhC,KAAIK,KAAKsB,UAAU3B,GACnBC,IAAII,KAAKsB,UAAU1B,GACnBC,IAAIG,KAAKsB,UAAUzB,IAAI,GACvBC,IAAIE,KAAKsB,UAAUxB,IAAI;AAG7BE,SAAK8B,KAAK,IAAIT,GAAS,IAAI5B,EAAIE,KAAIE,GAAGD,GAAGC,GAAGC,CAAAA,GAAI+C,EAAAA,GAChD7C,KAAKgC,KAAK,IAAIX,GAAS,IAAI5B,EAAIE,IAAGC,GAAGC,GAAGC,CAAAA,GAAI+C,EAAAA,GAC5C7C,KAAKiC,KAAK,IAAIZ,GAAS,IAAI5B,EAAIE,KAAIE,GAAGD,IAAIE,GAAGD,GAAGC,CAAAA,GAAI+C,EAAAA,GACpD7C,KAAKkC,KAAK,IAAIb,GAAS,IAAI5B,EAAIE,IAAGC,IAAIE,GAAGD,GAAGC,CAAAA,GAAI+C,EAAAA,GAEhD7C,KAAK8C,OAAO9C,KAAKwB,OAAOkB,MAAAA,CAAAA,GAGxB1C,KAAKwB,OAAOmB,SAAS,GACrB3C,KAAKwB,SAAS,CAAA;EAAA;EASlB9B,OAAOqD,IAAAA;AACH,QAAIT,MAAMU,QAAQD,EAAAA,EACd,YAAW9C,MAAS8C,GAChB/C,MAAKiD,gBAAgBhD,EAAAA;QAGzBD,MAAKiD,gBAAgBF,EAAAA;EAAAA;EAWrBrD,gBAAgBO,IAAAA;AACpB,QAAKD,KAAKsB,UAAU4B,SAASjD,EAAAA,EAI7B,KAAKD,KAAK2B,UAWV3B,MAAK8B,GAAGmB,gBAAgBhD,EAAAA,GACxBD,KAAKgC,GAAGiB,gBAAgBhD,EAAAA,GACxBD,KAAKiC,GAAGgB,gBAAgBhD,EAAAA,GACxBD,KAAKkC,GAAGe,gBAAgBhD,EAAAA,GAEpBD,KAAKuB,OAAOL,qBACyB,MAAjClB,KAAK8B,GAAGK,mBAAAA,KAA+BnC,KAAK8B,GAAGH,aACd,MAAjC3B,KAAKgC,GAAGG,mBAAAA,KAA+BnC,KAAKgC,GAAGL,aACd,MAAjC3B,KAAKiC,GAAGE,mBAAAA,KAA+BnC,KAAKiC,GAAGN,aACd,MAAjC3B,KAAKkC,GAAGC,mBAAAA,KAA+BnC,KAAKkC,GAAGP,cAE/C3B,KAAK2B,YAAAA,OAAY,OAEV3B,KAAK8B,IAAAA,OACL9B,KAAKgC,IAAAA,OACLhC,KAAKiC,IAAAA,OACLjC,KAAKkC;SA3BpB;AAEI,eAASiB,KADGnD,KAAKwB,OAAOmB,SACL,GAAGQ,MAAK,GAAGA,KACtBnD,MAAKuB,OAAOH,eAAenB,IAAOD,KAAKwB,OAAO2B,EAAAA,CAAAA,KAC9CnD,KAAKwB,OAAO4B,OAAOD,IAAG,CAAA;IAAA;EAAA;EAmCtCzD,OAAOqD,IAAAA;AACH,QAAIT,MAAMU,QAAQD,EAAAA,GAAe;AAC7B,UAAIM,KAAAA;AACJ,iBAAWpD,MAAS8C,GAChBM,CAAAA,KAAcA,MAAerD,KAAK4B,gBAAgB3B,EAAAA;AAEtD,aAAOoD;IAAAA;AAEP,WAAOrD,KAAK4B,gBAAgBmB,EAAAA;EAAAA;EAY5BrD,gBAAgBO,IAAAA;AACpB,QAAA,CAAKD,KAAKsB,UAAU4B,SAASjD,EAAAA,EACzB,QAAA;AAEJ,QAAA,CAAKD,KAAK2B,WAAW;AACjB,UAAI3B,KAAKmC,mBAAAA,IAAuBnC,KAAKuB,OAAON,YAAyC,MAA7BjB,KAAKuB,OAAOJ,aAEhE,QADAnB,KAAKwB,OAAOgB,KAAKvC,EAAAA,GAAAA;AACV,OAAA,OACAD,KAAKuB,OAAOJ,gBAAuBnB,KAAKuB,OAAOJ,eAAe,MACrEnB,KAAKsD,OAAAA;IAAAA;AAIb,WAAA,CAAA,CAAItD,KAAK2B,cACE3B,KAAK8B,GAAGF,gBAAgB3B,EAAAA,KACxBD,KAAKgC,GAAGJ,gBAAgB3B,EAAAA,KACxBD,KAAKiC,GAAGL,gBAAgB3B,EAAAA,KACxBD,KAAKkC,GAAGN,gBAAgB3B,EAAAA;EAAAA;EAWvCP,MAAMQ,IAAAA;AACF,UAAMqD,KAAuB,CAAA;AAE7B,WADAvD,KAAKwD,eAAetD,IAAOqD,EAAAA,GACpBA;EAAAA;EASH7D,eAAeQ,IAAcqD,IAAAA;AACjC,QAAIrD,GAAMuD,WAAWzD,KAAKsB,SAAAA,EACtB,KAAItB,KAAK2B,UACL3B,MAAK8B,GAAG0B,eAAetD,IAAOqD,EAAAA,GAC9BvD,KAAKgC,GAAGwB,eAAetD,IAAOqD,EAAAA,GAC9BvD,KAAKiC,GAAGuB,eAAetD,IAAOqD,EAAAA,GAC9BvD,KAAKkC,GAAGsB,eAAetD,IAAOqD,EAAAA;SAC3B;AACH,YAAMG,KAAI1D,KAAKwB,OAAOmC,OAAQ1D,CAAAA,OAAUC,GAAMgD,SAASjD,EAAAA,CAAAA;AAEvDqC,YAAMC,UAAUC,KAAKC,MAAMc,IAAaG,EAAAA;IAAAA;EAAAA;EAQpDhE,QAAAA;AACIM,SAAKwB,SAAS,CAAA,GACdxB,KAAK2B,YAAAA,OAAY,OAEV3B,KAAK8B,IAAAA,OACL9B,KAAKgC,IAAAA,OACLhC,KAAKiC,IAAAA,OACLjC,KAAKkC;EAAAA;AAAAA;",
  "names": ["Box", "[object Object]", "x", "y", "w", "h", "data", "this", "point", "range", "Circle", "r", "rPow2", "point1", "point2", "Math", "pow", "euclideanDistancePow2", "dX", "max", "min", "dY", "Point", "defaultConfig", "capacity", "removeEmptyNodes", "maximumDepth", "arePointsEqual", "QuadTree", "container", "config", "points", "Object", "assign", "isDivided", "insertRecursive", "tree", "ne", "getTree", "nw", "se", "sw", "getNodePointAmount", "pointsList", "getAllPointsRecursive", "Array", "prototype", "push", "apply", "slice", "length", "childMaximumDepth", "childConfig", "insert", "pointOrArray", "isArray", "removeRecursive", "contains", "i", "splice", "returnValue", "divide", "pointsFound", "queryRecursive", "intersects", "p", "filter"]
}
